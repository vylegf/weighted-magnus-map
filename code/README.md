#Планы
Планирую написать, по крайней мере, следующие программки:
* _write_generators.py_ - читает из файла/из командной строки список рёбер графа (или другое его представление); выводит в файл и на экран множество образующих Панова-Верёвкина. Прокачанная версия этой программы должна также выводить множество подкомплексов с нетривиальными H1, H2,...;
Хорошо бы ещё считать каждую эйлерову характеристику, мб рисовать подкомплексы где-нибудь,
выписывать ряды Пуанкаре.

* _multigraded_magnus.py_ - читает результат предыдущей программы, позволяет вычислять образы слов при отобр. Магнуса (компоненты весов вида \sum{j\in J} ej)
* _relation_bruteforce.py_ - по списку мультистепеней образующих выдаёт все способы составить из них коммутаторы, дающие нечто данной мультистепени
* _lie_presentation.py_ - (если получится это реализовать) задаёт мультиградуированную алгебру Ли образующими и соотношениями, вычисляет её таблицу умножения в степенях вида \sum{j\in J} ej.

#Формат
На примере. Пусть K - комплекс на трёх вершинах, первая и третья соединены ребром.
Список рёбер графа должен выглядеть как "3 02" (сначала передаём кол-во вершин, потом ребро,
соединяющее вершины под номерами 1 и 3; если вдруг цифры кончатся - исп. буквы).
В памяти он будет храниться как nx.Graph() на вершинах 0,1,2.

Список образующих должен выглядеть как "10 21 021" - имеются в виду вложенные коммутаторы (g2,g1), (g3,g2), (g1,(g3,g2)). Им будут приписаны имена a1, a2, b1. 
В памяти они хранятся как [[[1,0],[2,0]],[0,[2,1]]]; в высших размерностях будут пустые списки
(это позволяет восстановить количество вершин как len(gens)+1).
Есть два способа распечатки: либо b15=(g11,g3), либо bf=(a,2).

в мультиградуированном Магнусе должна быть возможность из строк вида a1A2B1a1 получать то, что сидит в соответствующей компоненте. Здесь A2 обозначает (a_2)^{-1}.
Программа, делающая брутфорс, как раз должна выдавать строки такого вида (видимо).

Принцип работы брутфорса:
1) рекурсивно ищем наборы образующих, сумма степеней которых \sum{j\in J}ej.
План: перебираем образующие ai, содержащие e{j1}, дальше пускаем рекурсию по \sum{j\in J\|ai|}ej.
2) когда такой набор зафиксирован, ему надо сопоставить все _слова Линдона_ длины |J|,
запрещая буквам повторяться. Должен быть алгоритм, так что надо что-то такое нагуглить.

Как хранить мультиградуированные штуки, я пока не понял, но, скорее всего, как словарь:
каждое число от 0 до 2^m-1 - ключ; каждому такому сопоставляется список (возможно, пустой;
но, видимо, надо всегда его создавать? или не стоит?)

#Текущий статус
* write_generators - есть считывание графа из файла, нахождение и распечатка образующих. Надо сделать:
** Построить флаговый симплициальный комплекс по графу
** Разобраться с библиотеками, которые умеют считать гомологии
** Нахождение и распечатка неодносвязных комплексов (с указанием чисел Бетти)
** Сохранение графа и/или образующих в файл
* multigraded_magnus - ничего не сделано. Надо сделать:
** Класс, хранящий комплекс и его образующие
(или хотя бы запись их степеней в какие-то глобальные константы) 
** Класс Z_2^m-градуированных полиномов с умножением, сложением, распечаткой, построением из строки.
* relation_bruteforce - ничего не сделано. Надо сделать:
** Рекурсивный поиск разбиения подкомплекса в непересекающееся объединение несвязных
** Перебор слов Линдона нужного вида
* lie_presentation - ничего не сделано. Надо сделать:
** Понять, как перебирать образующие свободной алгебры Ли и как на них устроено умножение
** Понять, как исключать образующие из соображений частичной коммутативности
** Определить гомоморфизм в тензорную алгебру
